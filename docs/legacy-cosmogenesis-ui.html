<!-- Archived legacy README UI preserved for lore. -->
# cathedral
Magnum opus monorepo — Brain (Cosmogenesis), Body (Stone Grimoire), Soul (Liber Arcanae).”
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cathedral of Circuits - Cosmogenesis Engine</title>
    <style>
        :root {
            /* Core Palette from perm-style.json */
            --void: #0B0B0B;
            --ink: #141414;
            --bone: #F8F5EF;
            --violet-core: #7A33FF;
            --violet-flare: #B39CFF;
            --violet-smoke: #442266;
            --gold-leaf: #C8A44D;
            --grail-gold: #CBB866;
            --pearl-white: #F5F2EA;
            --pearl-lilac: #CDB8F6;
            --astral-mist: #B7C9FF;
            --astral-silver: #C9D1E7;
            --astral-violet: #9E8BFF;
            --threshold-glow: #98FFE2;
            --teal-glow: #00CED1;
            --avalon-mist: #CFE6F2;
            --avalon-night: #0C1521;
            --obsidian-glass: #0f1014;
            --raku-copper: #b87333;
            --raku-violet: #6E00FF;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'EB Garamond', serif;
            background: radial-gradient(ellipse at center, var(--void) 0%, var(--obsidian-glass) 50%, var(--avalon-night) 100%);
            color: var(--bone);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ND-Safe Motion Control */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }

        /* Violet Gate Background Aura */
        .violet-gate-bg {
            position: fixed;
            top: 50%;
            left: 50%;
            width: min(90vw, 900px);
            height: min(90vw, 900px);
            transform: translate(-50%, -50%);
            z-index: 0;
            opacity: 0.06;
            pointer-events: none;
            border-radius: 50%;
            background:
                radial-gradient(40% 40% at 50% 60%, var(--violet-core), transparent 60%),
                radial-gradient(80% 60% at 50% 40%, color-mix(in oklab, var(--violet-flare), transparent 35%), transparent 70%),
                conic-gradient(from 0deg, rgba(122, 51, 255, .35), rgba(179, 156, 255, .22), rgba(68, 34, 102, .35));
        }

        .allow-motion .violet-gate-bg {
            animation: gentlePulse 18s ease-in-out infinite;
        }

        @keyframes gentlePulse {
            0%, 100% { opacity: 0.06; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.08; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* Main Layout */
        .cathedral-container {
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        @media (min-width: 1024px) {
            .cathedral-container {
                grid-template-columns: 1fr 400px;
            }
        }

        /* Canvas Area */
        .canvas-section {
            position: relative;
            background: linear-gradient(180deg, rgba(11, 11, 11, 0.95), rgba(13, 15, 24, 0.95));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(200, 164, 77, 0.2);
            border-radius: 16px;
            padding: 20px;
            min-height: 600px;
        }

        #geometryCanvas {
            width: 100%;
            height: 500px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Control Panel */
        .control-panel {
            background: linear-gradient(180deg, #0A0A0F, #0F1020);
            border: 1px solid rgba(255, 255, 255, .06);
            border-radius: 14px;
            padding: 25px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, .06),
                0 18px 44px rgba(0, 0, 0, .65);
            height: fit-content;
        }

        .control-panel h2 {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: var(--gold-leaf);
            text-shadow: 0 0 10px rgba(200, 164, 77, 0.5);
            letter-spacing: 2px;
            font-family: 'Cinzel', 'Georgia', serif;
        }

        /* Mode Selector */
        .mode-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .mode-title {
            font-size: 0.9em;
            color: var(--pearl-lilac);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .mode-btn {
            padding: 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--pearl-white);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
            text-align: center;
        }

        .mode-btn:hover {
            background: rgba(122, 51, 255, 0.15);
            border-color: var(--violet-flare);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--violet-core), var(--violet-flare));
            border-color: var(--gold-leaf);
            color: var(--void);
        }

        /* Geometry Selector */
        .geometry-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }

        .geo-btn {
            padding: 8px 4px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            color: var(--astral-mist);
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.3s;
            text-align: center;
        }

        .geo-btn:hover {
            background: rgba(122, 51, 255, 0.2);
            transform: scale(1.05);
        }

        .geo-btn.active {
            background: var(--violet-smoke);
            border-color: var(--violet-flare);
            color: var(--gold-leaf);
        }

        /* Solfeggio Panel */
        .solfeggio-panel {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(200, 164, 77, 0.2);
        }

        .solfeggio-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .solfeggio-chip {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px;
            border: 1px solid rgba(255, 255, 255, .10);
            border-radius: 8px;
            background: rgba(255, 255, 255, .04);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.7rem;
        }

        .solfeggio-chip:hover {
            background: rgba(122, 51, 255, 0.15);
            transform: translateY(-2px);
        }

        .solfeggio-chip.active {
            background: linear-gradient(135deg, var(--violet-core), var(--violet-flare));
            color: var(--void);
        }

        .solfeggio-chip .freq {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .solfeggio-chip .theme {
            font-size: 0.6rem;
            opacity: 0.8;
        }

        /* Witch Eye Orders */
        .witch-eye-section {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
        }

        .witch-eye-title {
            font-size: 0.85em;
            color: var(--gold-leaf);
            margin-bottom: 10px;
        }

        .order-chip {
            display: inline-block;
            padding: 6px 12px;
            margin: 4px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .order-chip:hover {
            background: rgba(122, 51, 255, 0.2);
            border-color: var(--violet-flare);
        }

        .order-chip.active {
            background: var(--violet-smoke);
            border-color: var(--gold-leaf);
            color: var(--gold-leaf);
        }

        /* Parameter Controls */
        .param-control {
            margin-bottom: 15px;
        }

        .param-label {
            display: block;
            font-size: 0.8rem;
            color: var(--astral-silver);
            margin-bottom: 5px;
        }

        .param-slider {
            width: 100%;
            appearance: none;
            height: 4px;
            background: linear-gradient(90deg, var(--violet-core), var(--teal-glow), var(--gold-leaf));
            border-radius: 2px;
            outline: none;
        }

        .param-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--pearl-white);
            border-radius: 50%;
            cursor: pointer;
        }

        .param-value {
            text-align: right;
            font-size: 0.75rem;
            color: var(--gold-leaf);
            margin-top: 2px;
        }

        /* Export Panel */
        .export-panel {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(200, 164, 77, 0.2);
            display: flex;
            gap: 10px;
        }

        .export-btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, var(--violet-core), var(--violet-flare));
            border: none;
            border-radius: 8px;
            color: var(--void);
            font-weight: bold;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(122, 51, 255, 0.4);
        }

        .export-btn.secondary {
            background: linear-gradient(135deg, var(--raku-violet), var(--teal-glow));
        }

        /* Node Info Display */
        .node-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(200, 164, 77, 0.2);
        }

        .node-title {
            font-size: 1.1em;
            color: var(--gold-leaf);
            margin-bottom: 10px;
        }

        .node-attributes {
            font-size: 0.85rem;
            color: var(--astral-mist);
            line-height: 1.6;
        }

        /* Protection Sigil */
        .protection-sigil {
            width: 60px;
            height: 60px;
            margin: 20px auto;
            border-radius: 50%;
            background:
                radial-gradient(40% 40% at 50% 50%, var(--teal-glow), transparent 60%),
                conic-gradient(from 0deg, rgba(255, 255, 255, .05), rgba(0, 0, 0, .06));
            outline: 1px solid rgba(200, 164, 77, 0.3);
            opacity: 0.6;
        }

        /* Loading State */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--void);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 1s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-sigil {
            width: 100px;
            height: 100px;
            border: 2px solid var(--violet-core);
            border-radius: 50%;
            animation: rotate 3s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-sigil"></div>
    </div>

    <!-- Violet Gate Background -->
    <div class="violet-gate-bg" aria-hidden="true"></div>

    <!-- Main Cathedral Container -->
    <div class="cathedral-container">
        <!-- Canvas Section -->
        <div class="canvas-section">
            <canvas id="geometryCanvas"></canvas>
            
            <div class="node-info">
                <div class="node-title" id="nodeTitle">Node 33: Guardian Gate</div>
                <div class="node-attributes" id="nodeAttributes">
                    <div>Frequency: <span id="nodeFreq">528 Hz</span></div>
                    <div>Geometry: <span id="nodeGeo">Superformula</span></div>
                    <div>Lineage: <span id="nodeLineage">Hermetic</span></div>
                    <div>Order: <span id="nodeOrder">Sovereign Eye</span></div>
                </div>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <h2>COSMOGENESIS</h2>

            <!-- Adventure Modes -->
            <div class="mode-section">
                <div class="mode-title">Adventure Mode</div>
                <div class="mode-grid">
                    <button class="mode-btn active" data-mode="hermetic">Hermetic</button>
                    <button class="mode-btn" data-mode="tree">Tree of Life</button>
                    <button class="mode-btn" data-mode="aeons">Aeons</button>
                    <button class="mode-btn" data-mode="avalon">Avalon</button>
                </div>
            </div>

            <!-- Geometry Selection -->
            <div class="mode-section">
                <div class="mode-title">Sacred Geometry</div>
                <div class="geometry-grid" id="geometryGrid">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <!-- Parameter Controls -->
            <div class="mode-section">
                <div class="mode-title">Parameters</div>
                <div class="param-control">
                    <label class="param-label">Complexity</label>
                    <input type="range" class="param-slider" id="complexitySlider" min="3" max="12" value="6">
                    <div class="param-value" id="complexityValue">6</div>
                </div>
                <div class="param-control">
                    <label class="param-label">Harmonics</label>
                    <input type="range" class="param-slider" id="harmonicsSlider" min="0.1" max="1.0" step="0.01" value="0.5">
                    <div class="param-value" id="harmonicsValue">0.5</div>
                </div>
                <div class="param-control">
                    <label class="param-label">Scale</label>
                    <input type="range" class="param-slider" id="scaleSlider" min="0.5" max="2.0" step="0.1" value="1.0">
                    <div class="param-value" id="scaleValue">1.0</div>
                </div>
            </div>

            <!-- Solfeggio Frequencies -->
            <div class="solfeggio-panel">
                <div class="mode-title">Solfeggio Healing</div>
                <div class="solfeggio-grid" id="solfeggioGrid">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <!-- Witch Eye Orders -->
            <div class="witch-eye-section">
                <div class="witch-eye-title">Witch Eye Orders</div>
                <div id="ordersContainer">
                    <span class="order-chip active" data-order="watchers">Watchers</span>
                    <span class="order-chip" data-order="flame">Flame</span>
                    <span class="order-chip" data-order="veil">Veil</span>
                    <span class="order-chip" data-order="sovereign">Sovereign Eye</span>
                </div>
            </div>

            <!-- Export Panel -->
            <div class="export-panel">
                <button class="export-btn" onclick="exportSVG()">Export SVG</button>
                <button class="export-btn secondary" onclick="exportResearch()">Export Research</button>
            </div>

            <!-- Protection Sigil -->
            <div class="protection-sigil" aria-hidden="true"></div>
        </div>
    </div>

    <script>
        // Cathedral State Management
        const cathedral = {
            currentMode: 'hermetic',
            currentGeometry: 'superformula',
            currentFrequency: 528,
            currentOrder: 'watchers',
            audioContext: null,
            oscillator: null,
            parameters: {
                complexity: 6,
                harmonics: 0.5,
                scale: 1.0
            }
        };

        // Sacred Geometry Engine
        class GeometryEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.time = 0;
                this.animationFrame = null;
                this.setupCanvas();
            }

            setupCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width - 40;
                this.canvas.height = 500;
            }

            render(type, params) {
                const { ctx, canvas } = this;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                
                // Set drawing style
                ctx.strokeStyle = getComputedStyle(document.documentElement)
                    .getPropertyValue('--gold-leaf');
                ctx.fillStyle = getComputedStyle(document.documentElement)
                    .getPropertyValue('--violet-flare');
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.8;
                
                switch(type) {
                    case 'superformula':
                        this.drawSuperformula(params);
                        break;
                    case 'lissajous':
                        this.drawLissajous(params);
                        break;
                    case 'rose':
                        this.drawRose(params);
                        break;
                    case 'spirograph':
                        this.drawSpirograph(params);
                        break;
                    case 'phyllotaxis':
                        this.drawPhyllotaxis(params);
                        break;
                    case 'harmonograph':
                        this.drawHarmonograph(params);
                        break;
                    case 'platonic':
                        this.drawPlatonic(params);
                        break;
                    case 'villard':
                        this.drawVillardGrid(params);
                        break;
                    case 'julia':
                        this.drawJuliaSet(params);
                        break;
                    default:
                        this.drawSuperformula(params);
                }
                
                ctx.restore();
            }

            drawSuperformula(params) {
                const m = params.complexity || 6;
                const n1 = params.harmonics || 0.5;
                const n2 = n1;
                const n3 = n1;
                const scale = params.scale * 150;
                
                this.ctx.beginPath();
                for (let theta = 0; theta <= Math.PI * 2; theta += 0.01) {
                    const r = this.superformulaRadius(theta, m, n1, n2, n3);
                    const x = r * Math.cos(theta) * scale;
                    const y = r * Math.sin(theta) * scale;
                    
                    if (theta === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.closePath();
                this.ctx.stroke();
            }

            superformulaRadius(theta, m, n1, n2, n3) {
                const a = 1, b = 1;
                const t1 = Math.abs((1/a) * Math.cos(m * theta / 4));
                const t2 = Math.abs((1/b) * Math.sin(m * theta / 4));
                const r = Math.pow(Math.pow(t1, n2) + Math.pow(t2, n3), -1/n1);
                return r;
            }

            drawLissajous(params) {
                const a = params.complexity || 3;
                const b = a + 1;
                const delta = params.harmonics * Math.PI;
                const scale = params.scale * 150;
                
                this.ctx.beginPath();
                for (let t = 0; t <= Math.PI * 2; t += 0.01) {
                    const x = Math.sin(a * t + delta) * scale;
                    const y = Math.sin(b * t) * scale;
                    
                    if (t === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }

            drawRose(params) {
                const k = params.complexity || 5;
                const scale = params.scale * 150;
                
                this.ctx.beginPath();
                for (let theta = 0; theta <= Math.PI * 2; theta += 0.01) {
                    const r = Math.cos(k * theta) * scale;
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    
                    if (theta === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }

            drawSpirograph(params) {
                const R = 100 * params.scale;
                const r = R / params.complexity;
                const p = r * params.harmonics * 2;
                
                this.ctx.beginPath();
                for (let t = 0; t <= Math.PI * 2 * params.complexity; t += 0.01) {
                    const x = (R - r) * Math.cos(t) + p * Math.cos((R - r) * t / r);
                    const y = (R - r) * Math.sin(t) - p * Math.sin((R - r) * t / r);
                    
                    if (t === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }

            drawPhyllotaxis(params) {
                const n = Math.floor(params.complexity * 100);
                const angleInc = 137.508 * Math.PI / 180; // Golden angle
                const scale = params.scale * 5;
                
                for (let i = 0; i < n; i++) {
                    const r = scale * Math.sqrt(i);
                    const theta = i * angleInc;
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            drawHarmonograph(params) {
                const f1 = params.complexity;
                const f2 = f1 * 1.01;
                const p1 = 0;
                const p2 = params.harmonics * Math.PI;
                const d = 0.002;
                const scale = params.scale * 150;
                
                this.ctx.beginPath();
                for (let t = 0; t < 100; t += 0.01) {
                    const x = Math.sin(f1 * t + p1) * Math.exp(-d * t) * scale;
                    const y = Math.sin(f2 * t + p2) * Math.exp(-d * t) * scale;
                    
                    if (t === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }

            drawPlatonic(params) {
                const sides = Math.floor(params.complexity);
                const radius = params.scale * 150;
                
                // Draw outer shape
                this.ctx.beginPath();
                for (let i = 0; i <= sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.closePath();
                this.ctx.stroke();
                
                // Draw internal connections
                if (params.harmonics > 0.5) {
                    this.ctx.globalAlpha = 0.3;
                    for (let i = 0; i < sides; i++) {
                        for (let j = i + 2; j < sides; j++) {
                            const angle1 = (i / sides) * Math.PI * 2 - Math.PI / 2;
                            const angle2 = (j / sides) * Math.PI * 2 - Math.PI / 2;
                            
                            this.ctx.beginPath();
                            this.ctx.moveTo(Math.cos(angle1) * radius, Math.sin(angle1) * radius);
                            this.ctx.lineTo(Math.cos(angle2) * radius, Math.sin(angle2) * radius);
                            this.ctx.stroke();
                        }
                    }
                }
            }

            drawVillardGrid(params) {
                const divisions = Math.floor(params.complexity);
                const size = params.scale * 200;
                const step = size * 2 / divisions;
                
                this.ctx.globalAlpha = 0.5;
                
                // Draw grid
                for (let i = 0; i <= divisions; i++) {
                    const pos = -size + i * step;
                    
                    // Vertical lines
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos, -size);
                    this.ctx.lineTo(pos, size);
                    this.ctx.stroke();
                    
                    // Horizontal lines
                    this.ctx.beginPath();
                    this.ctx.moveTo(-size, pos);
                    this.ctx.lineTo(size, pos);
                    this.ctx.stroke();
                }
                
                // Draw diagonals if harmonics > 0.5
                if (params.harmonics > 0.5) {
                    this.ctx.globalAlpha = 0.3;
                    for (let i = 0; i <= divisions; i++) {
                        const pos = -size + i * step;
                        
                        // Diagonal from top-left
                        this.ctx.beginPath();
                        this.ctx.moveTo(-size, pos);
                        this.ctx.lineTo(pos, -size);
                        this.ctx.stroke();
                        
                        // Diagonal from top-right
                        this.ctx.beginPath();
                        this.ctx.moveTo(size, pos);
                        this.ctx.lineTo(pos, size);
                        this.ctx.stroke();
                    }
                }
            }

            drawJuliaSet(params) {
                const width = 400;
                const height = 400;
                const cx = -0.7 + params.harmonics * 0.3;
                const cy = 0.27015;
                const zoom = params.scale;
                const maxIter = Math.floor(params.complexity * 10);
                
                // Create temporary canvas for Julia set
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                const imageData = tempCtx.createImageData(width, height);
                
                for (let px = 0; px < width; px++) {
                    for (let py = 0; py < height; py++) {
                        let x = (px - width/2) / (0.5 * zoom * width) * 4;
                        let y = (py - height/2) / (0.5 * zoom * height) * 4;
                        
                        let i = 0;
                        while (x*x + y*y < 4 && i < maxIter) {
                            const xtemp = x*x - y*y + cx;
                            y = 2*x*y + cy;
                            x = xtemp;
                            i++;
                        }
                        
                        const idx = (py * width + px) * 4;
                        const color = i === maxIter ? 0 : (i / maxIter) * 255;
                        
                        // Use theme colors
                        if (i === maxIter) {
                            imageData.data[idx] = 11;     // void
                            imageData.data[idx + 1] = 11;
                            imageData.data[idx + 2] = 11;
                        } else {
                            const t = i / maxIter;
                            imageData.data[idx] = 122 * t;     // violet
                            imageData.data[idx + 1] = 51 * t;
                            imageData.data[idx + 2] = 255 * t;
                        }
                        imageData.data[idx + 3] = 255;
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                this.ctx.drawImage(tempCanvas, -width/2, -height/2);
            }

            animate() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                
                const animateFrame = () => {
                    this.time += 0.01;
                    
                    // Only animate with motion opt-in
                    if (document.body.classList.contains('allow-motion')) {
                        // Gentle 18-second sweep (ND-safe)
                        cathedral.parameters.harmonics = 0.5 + Math.sin(this.time * 0.35) * 0.3;
                        updateParameterDisplay();
                        this.render(cathedral.currentGeometry, cathedral.parameters);
                    }
                    
                    this.animationFrame = requestAnimationFrame(animateFrame);
                };
                
                animateFrame();
            }
        }

        // Audio Engine for Solfeggio Frequencies
        class SolfeggioEngine {
            constructor() {
                this.context = null;
                this.oscillator = null;
                this.gainNode = null;
                this.isPlaying = false;
            }

            init() {
                if (!this.context) {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.context.createGain();
                    this.gainNode.connect(this.context.destination);
                    this.gainNode.gain.value = 0.1; // Low volume for safety
                }
            }

            playFrequency(freq) {
                this.init();
                this.stop();
                
                this.oscillator = this.context.createOscillator();
                this.oscillator.type = 'sine';
                this.oscillator.frequency.setValueAtTime(freq, this.context.currentTime);
                this.oscillator.connect(this.gainNode);
                
                // Gentle fade in
                this.gainNode.gain.setValueAtTime(0, this.context.currentTime);
                this.gainNode.gain.linearRampToValueAtTime(0.1, this.context.currentTime + 0.3);
                
                this.oscillator.start();
                this.isPlaying = true;
            }

            stop() {
                if (this.oscillator && this.isPlaying) {
                    // Gentle fade out
                    this.gainNode.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.3);
                    this.oscillator.stop(this.context.currentTime + 0.3);
                    this.oscillator = null;
                    this.isPlaying = false;
                }
            }
        }

        // Initialize components
        const canvas = document.getElementById('geometryCanvas');
        const geometryEngine = new GeometryEngine(canvas);
        const audioEngine = new SolfeggioEngine();

        // Geometry types with their parameters
        const geometryTypes = [
            { id: 'superformula', name: 'Superformula' },
            { id: 'lissajous', name: 'Lissajous' },
            { id: 'rose', name: 'Rose' },
            { id: 'spirograph', name: 'Spirograph' },
            { id: 'phyllotaxis', name: 'Phyllotaxis' },
            { id: 'harmonograph', name: 'Harmonograph' },
            { id: 'platonic', name: 'Platonic' },
            { id: 'villard', name: 'Villard Grid' },
            { id: 'julia', name: 'Julia Set' }
        ];

        // Solfeggio frequencies with meanings
        const solfeggioFrequencies = [
            { freq: 396, theme: 'Liberation' },
            { freq: 417, theme: 'Transmute' },
            { freq: 432, theme: 'Heart' },
            { freq: 528, theme: 'Repattern' },
            { freq: 639, theme: 'Relational' },
            { freq: 741, theme: 'Clarity' },
            { freq: 852, theme: 'Intuition' },
            { freq: 963, theme: 'Unitive' }
        ];

        // Initialize UI
        function initializeUI() {
            // Populate geometry grid
            const geoGrid = document.getElementById('geometryGrid');
            geometryTypes.forEach(geo => {
                const btn = document.createElement('button');
                btn.className = 'geo-btn';
                btn.textContent = geo.name;
                btn.dataset.geometry = geo.id;
                if (geo.id === cathedral.currentGeometry) {
                    btn.classList.add('active');
                }
                btn.onclick = () => selectGeometry(geo.id);
                geoGrid.appendChild(btn);
            });

            // Populate Solfeggio grid
            const solGrid = document.getElementById('solfeggioGrid');
            solfeggioFrequencies.forEach(sol => {
                const chip = document.createElement('div');
                chip.className = 'solfeggio-chip';
                chip.dataset.freq = sol.freq;
                if (sol.freq === cathedral.currentFrequency) {
                    chip.classList.add('active');
                }
                chip.innerHTML = `
                    <span class="freq">${sol.freq} Hz</span>
                    <span class="theme">${sol.theme}</span>
                `;
                chip.onclick = () => selectFrequency(sol.freq);
                solGrid.appendChild(chip);
            });

            // Setup mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => selectMode(btn.dataset.mode));
            });

            // Setup order chips
            document.querySelectorAll('.order-chip').forEach(chip => {
                chip.addEventListener('click', () => selectOrder(chip.dataset.order));
            });

            // Setup parameter sliders
            setupParameterControls();

            // Hide loading overlay
            setTimeout(() => {
                document.getElementById('loadingOverlay').classList.add('hidden');
            }, 1500);

            // Initial render
            geometryEngine.render(cathedral.currentGeometry, cathedral.parameters);
            geometryEngine.animate();
        }

        function setupParameterControls() {
            // Complexity slider
            const complexitySlider = document.getElementById('complexitySlider');
            const complexityValue = document.getElementById('complexityValue');
            complexitySlider.addEventListener('input', (e) => {
                cathedral.parameters.complexity = parseFloat(e.target.value);
                complexityValue.textContent = e.target.value;
                geometryEngine.render(cathedral.currentGeometry, cathedral.parameters);
            });

            // Harmonics slider
            const harmonicsSlider = document.getElementById('harmonicsSlider');
            const harmonicsValue = document.getElementById('harmonicsValue');
            harmonicsSlider.addEventListener('input', (e) => {
                cathedral.parameters.harmonics = parseFloat(e.target.value);
                harmonicsValue.textContent = e.target.value;
                geometryEngine.render(cathedral.currentGeometry, cathedral.parameters);
            });

            // Scale slider
            const scaleSlider = document.getElementById('scaleSlider');
            const scaleValue = document.getElementById('scaleValue');
            scaleSlider.addEventListener('input', (e) => {
                cathedral.parameters.scale = parseFloat(e.target.value);
                scaleValue.textContent = e.target.value;
                geometryEngine.render(cathedral.currentGeometry, cathedral.parameters);
            });
        }

        function updateParameterDisplay() {
            document.getElementById('complexityValue').textContent = 
                cathedral.parameters.complexity.toFixed(0);
            document.getElementById('harmonicsValue').textContent = 
                cathedral.parameters.harmonics.toFixed(2);
            document.getElementById('scaleValue').textContent = 
                cathedral.parameters.scale.toFixed(1);
            
            document.getElementById('complexitySlider').value = cathedral.parameters.complexity;
            document.getElementById('harmonicsSlider').value = cathedral.parameters.harmonics;
            document.getElementById('scaleSlider').value = cathedral.parameters.scale;
        }

        function selectGeometry(geoId) {
            cathedral.currentGeometry = geoId;
            
            // Update UI
            document.querySelectorAll('.geo-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.geometry === geoId);
            });
            
            // Update node info
            document.getElementById('nodeGeo').textContent = 
                geometryTypes.find(g => g.id === geoId).name;
            
            // Render new geometry
            geometryEngine.render(cathedral.currentGeometry, cathedral.parameters);
        }

        function selectFrequency(freq) {
            cathedral.currentFrequency = freq;
            
            // Update UI
            document.querySelectorAll('.solfeggio-chip').forEach(chip => {
                chip.classList.toggle('active', parseInt(chip.dataset.freq) === freq);
            });
            
            // Update node info
            document.getElementById('nodeFreq').textContent = `${freq} Hz`;
            
            // Play frequency if motion is enabled
            if (document.body.classList.contains('allow-motion')) {
                audioEngine.playFrequency(freq);
            }
        }

        function selectMode(mode) {
            cathedral.currentMode = mode;
            
            // Update UI
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            
            // Update node info
            document.getElementById('nodeLineage').textContent = 
                mode.charAt(0).toUpperCase() + mode.slice(1);
            
            // Enable motion for game modes
            if (mode === 'hermetic' || mode === 'tree') {
                document.body.classList.add('allow-motion');
            } else {
                document.body.classList.remove('allow-motion');
                audioEngine.stop();
            }
        }

        function selectOrder(order) {
            cathedral.currentOrder = order;
            
            // Update UI
            document.querySelectorAll('.order-chip').forEach(chip => {
                chip.classList.toggle('active', chip.dataset.order === order);
            });
            
            // Update node info
            const orderNames = {
                'watchers': 'Watchers',
                'flame': 'Flame',
                'veil': 'Veil',
                'sovereign': 'Sovereign Eye'
            };
            document.getElementById('nodeOrder').textContent = orderNames[order];
        }

        // Export functions
        function exportSVG() {
            // Create SVG from canvas
            const svgNS = 'http://www.w3.org/2000/svg';
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('width', canvas.width);
            svg.setAttribute('height', canvas.height);
            svg.setAttribute('viewBox', `0 0 ${canvas.width} ${canvas.height}`);
            
            // Add metadata
            const metadata = document.createElementNS(svgNS, 'metadata');
            metadata.textContent = JSON.stringify({
                node: document.getElementById('nodeTitle').textContent,
                frequency: cathedral.currentFrequency,
                geometry: cathedral.currentGeometry,
                parameters: cathedral.parameters,
                timestamp: new Date().toISOString()
            });
            svg.appendChild(metadata);
            
            // Convert and download
            const svgBlob = new Blob([svg.outerHTML], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(svgBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cathedral_${Date.now()}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportResearch() {
            // Create research package
            const researchData = {
                metadata: {
                    project: 'Cathedral of Circuits',
                    node: document.getElementById('nodeTitle').textContent,
                    timestamp: new Date().toISOString(),
                    nd_safe: true,
                    provenance: 'CC-BY-NC'
                },
                configuration: {
                    mode: cathedral.currentMode,
                    geometry: cathedral.currentGeometry,
                    frequency: cathedral.currentFrequency,
                    order: cathedral.currentOrder,
                    parameters: cathedral.parameters
                },
                solfeggio_mapping: solfeggioFrequencies,
                geometry_types: geometryTypes,
                witch_eye_orders: ['watchers', 'flame', 'veil', 'sovereign_eye'],
                notes: 'Exported from Cosmogenesis Learning Engine'
            };
            
            // Download as JSON
            const blob = new Blob([JSON.stringify(researchData, null, 2)], 
                { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `research_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            geometryEngine.setupCanvas();
            geometryEngine.render(cathedral.currentGeometry, cathedral.parameters);
        });

        // Initialize on load
        window.addEventListener('load', initializeUI);

        // Make export functions globally available
        window.exportSVG = exportSVG;
        window.exportResearch = exportResearch;
    </script>
</body>
</html>
                        
