// Cathedral of Circuits - Core Foundation System
// Based on Codex 144:99 with trauma-informed design principles
// Author: Rebecca Respawn (Bekalah) - Architect-Scribe

/*
FOUNDATION ARCHITECTURE OVERVIEW:

This system provides the foundational layer for your Cathedral of Circuits project.
It implements your core requirements:

- Node-based architecture following C144N-### pattern
- ND-safe protocols (no strobe, controlled motion, safe stops)
- Sacred geometry constants (21, 33, 72, 78, 99, 144, 243)
- Color harmonics integration
- Golden ratio proportions
- IFS (Internal Family Systems) layer support
- Trauma-informed pacing controls

The architecture uses vanilla JavaScript with Web Components for maximum
compatibility and minimal dependencies, following your covenant requirements.
*/

// Sacred constants from Codex 144:99
const SACRED_CONSTANTS = {
PILLARS: 21,
SPINE: 33,
SHEM: 72,
ARCHETYPES: 78,
GATES: 99,
LATTICE: 144,
COMPLETION: 243,
PHI: (1 + Math.sqrt(5)) / 2  // Golden ratio
};

// Color harmonics system - connects frequencies to colors
const ColorHarmonics = {
// Base frequencies for chakra/color correspondence
frequencies: {
ROOT: 194.18,    // Red - C
SACRAL: 210.42,  // Orange - D
SOLAR: 126.22,   // Yellow - E
HEART: 341.3,    // Green - F
THROAT: 384,     // Blue - G
THIRD_EYE: 426.7, // Indigo - A
CROWN: 480       // Violet - B
},

// Convert frequency to HSL color values
frequencyToColor(hz) {
// Map frequency range to hue (0-360)
const minHz = 100;
const maxHz = 800;
const normalizedHz = Math.max(0, Math.min(1, (hz - minHz) / (maxHz - minHz)));
const hue = normalizedHz * 360;

```
return {
  h: Math.round(hue),
  s: 70, // Moderate saturation for ND-safe viewing
  l: 55  // Balanced lightness
};
```

},

// Generate harmonic series from base frequency
generateHarmonics(baseHz, count = 7) {
return Array.from({length: count}, (_, i) => baseHz * (i + 1));
}
};

// ND-Safe motion controller - respects trauma-informed design
class NDSafeMotion {
constructor() {
this.motionEnabled = this.checkMotionPreference();
this.intensity = 0.3; // Default to gentle motion
this.safeStopTriggered = false;
}

checkMotionPreference() {
// Respect system accessibility preferences
const prefersReducedMotion = window.matchMedia(’(prefers-reduced-motion: reduce)’).matches;
return !prefersReducedMotion;
}

// Safe stop - immediately halt all motion
safeStop() {
this.safeStopTriggered = true;
this.motionEnabled = false;
document.documentElement.style.setProperty(’–motion-scale’, ‘0’);

```
// Emit safe stop event for other components
window.dispatchEvent(new CustomEvent('nd-safe-stop'));
```

}

// Set motion intensity (0-1 scale)
setIntensity(level) {
this.intensity = Math.max(0, Math.min(1, level));
document.documentElement.style.setProperty(’–motion-intensity’, this.intensity.toString());
}

// Check if motion is safe to use
isMotionSafe() {
return this.motionEnabled && !this.safeStopTriggered;
}
}

// Core Node class - represents elements in your C144N system
class CathedralNode {
constructor(id, config = {}) {
this.id = id;
this.gate = config.gate || null;
this.treePath = config.treePath || ‘’;
this.tarotOverlays = config.tarotOverlays || [];
this.numerology = config.numerology || this.calculateNumerology(id);
this.layers = {
study_seed: config.studySeed || ‘’,
research: config.research || ‘’,
art: config.art || null,
spell: config.spell || null,
safety: config.safety || { strobe: false, autoplay: false, motion: ‘calm’ }
};

```
// IFS layer support
this.ifsParts = config.ifsParts || [];
this.primaryArchetype = config.primaryArchetype || null;

this.validateNode();
```

}

// Extract number from node ID and calculate numerology
calculateNumerology(nodeId) {
const match = nodeId.match(/C144N-(\d{3})/);
if (!match) return 0;

```
const num = parseInt(match[1]);
return this.reduceToSingleDigit(num);
```

}

reduceToSingleDigit(num) {
while (num >= 10) {
num = num.toString().split(’’).reduce((sum, digit) => sum + parseInt(digit), 0);
}
return num;
}

// Validate node follows Codex 144:99 patterns
validateNode() {
if (!this.id.match(/^C144N-\d{3}$/)) {
throw new Error(`Invalid node ID: ${this.id}. Must follow C144N-### pattern`);
}

```
if (this.layers.safety.strobe === true) {
  throw new Error('PROTECT violation: strobe effects not permitted');
}

return true;
```

}

// Get harmonic frequency for this node
getHarmonicFrequency() {
const baseFreq = 256; // C4 as base
const nodeNumber = parseInt(this.id.match(/\d{3}$/)[0]);

```
// Use golden ratio and numerology to determine frequency
const phi = SACRED_CONSTANTS.PHI;
const multiplier = Math.pow(phi, this.numerology / 7);

return baseFreq * multiplier;
```

}

// Get color palette for this node
getColorPalette() {
const freq = this.getHarmonicFrequency();
const primaryColor = ColorHarmonics.frequencyToColor(freq);

```
// Generate harmonious colors using golden ratio intervals
const harmonics = ColorHarmonics.generateHarmonics(freq, 5);
const palette = harmonics.map(hz => ColorHarmonics.frequencyToColor(hz));

return {
  primary: primaryColor,
  harmonics: palette,
  cssVars: this.generateCSSVariables(primaryColor, palette)
};
```

}

generateCSSVariables(primary, harmonics) {
const vars = {
[`--node-${this.id}-primary-h`]: primary.h,
[`--node-${this.id}-primary-s`]: `${primary.s}%`,
[`--node-${this.id}-primary-l`]: `${primary.l}%`,
[`--node-${this.id}-primary`]: `hsl(${primary.h}, ${primary.s}%, ${primary.l}%)`
};

```
harmonics.forEach((color, i) => {
  vars[`--node-${this.id}-harmonic-${i}`] = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;
});

return vars;
```

}
}

// Spiral lattice system - core navigation structure
class SpiralLattice {
constructor(centerX, centerY, maxRadius) {
this.centerX = centerX;
this.centerY = centerY;
this.maxRadius = maxRadius;
this.nodes = new Map();
this.phi = SACRED_CONSTANTS.PHI;
}

// Calculate position in spiral for given node
calculateSpiralPosition(nodeIndex) {
const totalNodes = SACRED_CONSTANTS.LATTICE;
const angle = (nodeIndex / totalNodes) * Math.PI * 2 * SACRED_CONSTANTS.PILLARS; // 21 rotations
const radius = this.maxRadius * Math.pow(nodeIndex / totalNodes, 1 / this.phi);

```
return {
  x: this.centerX + Math.cos(angle) * radius,
  y: this.centerY + Math.sin(angle) * radius,
  angle: angle,
  radius: radius
};
```

}

// Add node to lattice
addNode(node, position = null) {
if (!position) {
const nodeNumber = parseInt(node.id.match(/\d{3}$/)[0]);
position = this.calculateSpiralPosition(nodeNumber);
}

```
this.nodes.set(node.id, {
  node: node,
  position: position,
  connections: []
});
```

}

// Find nodes within harmonic resonance range
findHarmonicNeighbors(nodeId, resonanceRange = 0.1) {
const sourceNode = this.nodes.get(nodeId);
if (!sourceNode) return [];

```
const sourceFreq = sourceNode.node.getHarmonicFrequency();
const neighbors = [];

for (const [id, nodeData] of this.nodes) {
  if (id === nodeId) continue;
  
  const targetFreq = nodeData.node.getHarmonicFrequency();
  const ratio = Math.abs(sourceFreq - targetFreq) / sourceFreq;
  
  if (ratio <= resonanceRange) {
    neighbors.push({
      id: id,
      resonance: 1 - ratio,
      node: nodeData.node
    });
  }
}

return neighbors.sort((a, b) => b.resonance - a.resonance);
```

}
}

// Main Cathedral system - coordinates all components
class CathedralOfCircuits {
constructor(containerId) {
this.container = document.getElementById(containerId);
this.motionController = new NDSafeMotion();
this.lattice = null;
this.currentNode = null;
this.nodes = new Map();

```
this.init();
```

}

init() {
this.createControls();
this.setupEventListeners();
this.loadSavedState();

```
// Initialize lattice based on container size
const rect = this.container.getBoundingClientRect();
const centerX = rect.width / 2;
const centerY = rect.height / 2;
const maxRadius = Math.min(rect.width, rect.height) * 0.4;

this.lattice = new SpiralLattice(centerX, centerY, maxRadius);
```

}

createControls() {
const controlsHTML = `
<div class="cathedral-controls" style="
position: fixed;
top: 20px;
right: 20px;
background: rgba(0, 0, 0, 0.8);
color: white;
padding: 15px;
border-radius: 8px;
font-family: monospace;
z-index: 1000;
">
<h3 style="margin: 0 0 10px 0;">Cathedral Controls</h3>

```
    <div class="motion-controls">
      <label>Motion Intensity:</label>
      <input type="range" id="motionSlider" min="0" max="1" step="0.1" value="${this.motionController.intensity}">
      <button id="safeStopBtn" style="background: #cc0000; color: white; border: none; padding: 5px 10px; margin-left: 10px;">
        SAFE STOP
      </button>
    </div>
    
    <div class="node-info" style="margin-top: 10px;">
      <div id="currentNodeDisplay">No node selected</div>
      <div id="harmonicDisplay"></div>
    </div>
    
    <div class="lattice-stats" style="margin-top: 10px; font-size: 0.8em;">
      <div>Nodes loaded: <span id="nodeCount">0</span></div>
      <div>Active connections: <span id="connectionCount">0</span></div>
    </div>
  </div>
`;

this.container.insertAdjacentHTML('beforeend', controlsHTML);
```

}

setupEventListeners() {
// Motion controls
document.getElementById(‘motionSlider’).addEventListener(‘input’, (e) => {
this.motionController.setIntensity(parseFloat(e.target.value));
});

```
document.getElementById('safeStopBtn').addEventListener('click', () => {
  this.motionController.safeStop();
});

// Listen for safe stop events
window.addEventListener('nd-safe-stop', () => {
  this.handleSafeStop();
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    this.motionController.safeStop();
  }
});
```

}

// Create and add a node to the system
createNode(id, config = {}) {
try {
const node = new CathedralNode(id, config);
this.nodes.set(id, node);
this.lattice.addNode(node);

```
  // Update display
  this.updateStats();
  
  // Apply color palette to CSS
  const palette = node.getColorPalette();
  Object.entries(palette.cssVars).forEach(([prop, value]) => {
    document.documentElement.style.setProperty(prop, value);
  });
  
  return node;
} catch (error) {
  console.error('Failed to create node:', error.message);
  return null;
}
```

}

// Select and activate a node
selectNode(nodeId) {
const node = this.nodes.get(nodeId);
if (!node) return false;

```
this.currentNode = node;

// Update display
document.getElementById('currentNodeDisplay').textContent = `Current: ${nodeId}`;

const freq = node.getHarmonicFrequency().toFixed(2);
document.getElementById('harmonicDisplay').textContent = `Frequency: ${freq}Hz`;

// Find harmonic neighbors
const neighbors = this.lattice.findHarmonicNeighbors(nodeId);
console.log(`Harmonic neighbors for ${nodeId}:`, neighbors);

return true;
```

}

handleSafeStop() {
// Implement emergency stop procedures
console.log(‘Safe stop activated - all motion halted’);

```
// Clear any running animations
this.container.querySelectorAll('*').forEach(el => {
  el.style.animation = 'none';
  el.style.transition = 'none';
});
```

}

updateStats() {
document.getElementById(‘nodeCount’).textContent = this.nodes.size;
// Connection count would be calculated based on active harmonic relationships
}

loadSavedState() {
// Load any previously saved configuration
const saved = localStorage.getItem(‘cathedral-state’);
if (saved) {
try {
const state = JSON.parse(saved);
this.motionController.setIntensity(state.motionIntensity || 0.3);
} catch (error) {
console.warn(‘Could not load saved state:’, error);
}
}
}

// Export current configuration
exportConfiguration() {
const config = {
nodes: Array.from(this.nodes.entries()).map(([id, node]) => ({
id: id,
gate: node.gate,
treePath: node.treePath,
tarotOverlays: node.tarotOverlays,
layers: node.layers
})),
motionIntensity: this.motionController.intensity,
timestamp: new Date().toISOString()
};

```
return JSON.stringify(config, null, 2);
```

}
}

// Usage example - how to initialize the system
function initializeCathedral() {
// Create the main system
const cathedral = new CathedralOfCircuits(‘cathedral-container’);

// Create some example nodes following your patterns
cathedral.createNode(‘C144N-001’, {
gate: ‘G-099-01’,
treePath: ‘Kether → Chokmah (Aleph)’,
tarotOverlays: [‘LA-00-FOOL’],
studySeed: ‘The Fool begins the journey’,
ifsParts: [‘Inner Child’, ‘Creative Spirit’],
primaryArchetype: ‘Beginner’
});

cathedral.createNode(‘C144N-017’, {
gate: ‘G-099-17’,
treePath: ‘Netzach → Yesod (Tzaddi)’,
tarotOverlays: [‘LA-17-STAR’],
studySeed: ‘Hope illuminates the path’,
ifsParts: [‘Visionary’, ‘Healer’],
primaryArchetype: ‘Guide’
});

cathedral.createNode(‘C144N-144’, {
gate: ‘G-099-99’,
treePath: ‘Malkuth (Completion)’,
tarotOverlays: [‘LA-21-WORLD’],
studySeed: ‘The lattice completes itself’,
ifsParts: [‘Wise Elder’, ‘Integration Master’],
primaryArchetype: ‘Completion’
});

// Select the first node to demonstrate
cathedral.selectNode(‘C144N-001’);

return cathedral;
}

// Export for use in other modules
if (typeof module !== ‘undefined’ && module.exports) {
module.exports = {
CathedralOfCircuits,
CathedralNode,
SpiralLattice,
ColorHarmonics,
NDSafeMotion,
SACRED_CONSTANTS
};
}